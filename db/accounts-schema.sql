create schema accounts;

create table accounts.subscriptions (
    subscription_id integer generated by default as identity,
    name varchar(50) not null,
    description varchar,
    month_duration int not null,
    price int not null,
    max_resources_count int null,
    constraint price_not_negative check (price >= 0),
    constraint days_duration_positive check (month_duration > 0),
    constraint subscriptions_primary_key primary key (subscription_id),
    constraint max_resources_null_or_positive check ( max_resources_count is null or max_resources_count > 0 )
);

create table accounts.roles (
    role_id integer generated by default as identity,
    name varchar not null,
    normalized_name varchar generated always as ( upper(name) ) stored,
    constraint roles_primary_key primary key (role_id)
);

create table accounts.users (
    user_id integer generated by default as identity,
    username varchar not null,
    normalized_username varchar generated always as ( upper(username) ) stored,
    email varchar not null,
    normalized_email varchar generated always as ( upper(email) ) stored,
    password_hash varchar not null,
    concurrency_stamp text not null,
    email_confirmed bool not null,
    lockout_enabled boolean not null,
    lockout_end timestamp with time zone,
    phone_number text not null,
    security_stamp text not null,
    access_failed_count integer not null,
    two_factor_enabled boolean not null,
    phone_number_confirmed boolean not null,
    constraint users_primary_key primary key (user_id)
);

create table accounts.users_roles (
    user_id int not null,
    role_id int not null,
    constraint users_roles_user_id_foreign_key foreign key (user_id) references accounts.users(user_id) on delete cascade,
    constraint users_roles_role_id_foreign_key foreign key (role_id) references accounts.roles(role_id) on delete cascade
);

create table accounts.users_roles (
    user_role_id int generated by default as identity,
    user_id int not null,
    role_id int not null,
    constraint no_roles_duplicates_for_user unique (user_id, role_id),
    constraint user_id_foreign_key foreign key (user_id) references accounts.users(user_id),
    constraint role_id_foreign_key foreign key (role_id) references accounts.roles(role_id)
);

-- For equality comparison for 'user_id' in gist
create extension btree_gist;

drop table accounts.users_subscriptions cascade;

create table accounts.users_subscriptions (
    user_subscription_id integer generated by default as identity,
    user_id int not null,
    subscription_id int references accounts.subscriptions(subscription_id) not null,
    used_resources_count int default 0,
    during daterange not null,
    constraint max_1_subscription_per_user_at_time exclude using gist(user_id with =, during with &&),
    constraint users_subscriptions_primary_key primary key (user_subscription_id),
    constraint used_resources_count_not_negative check ( used_resources_count >= 0 ),
    constraint users_subscriptions_users_user_id_foreign_key foreign key (user_id) references accounts.users(user_id) on delete cascade,
    constraint users_subscriptions_subscriptions_subscription_id_foreign_key foreign key (subscription_id) references accounts.subscriptions(subscription_id) on delete cascade
);


create view accounts.active_users_subscriptions as
    (select us.user_id as user_id,
            us.subscription_id as subscription_id,
            us.used_resources_count as used_resources_count,
            us.during as during,
            s.max_resources_count as max_resources_count
    from accounts.users_subscriptions as us
    join accounts.subscriptions as s on us.subscription_id = s.subscription_id
    where us.during @> current_date and
          (s.max_resources_count is null or
           s.max_resources_count > us.used_resources_count)
    );

create or replace function check_resources_left_count_for_user_function() returns trigger as $$
    declare
        max_amount int;
    begin

        if (tg_op = 'INSERT' or tg_op = 'UPDATE') then
            max_amount = (select s.max_resources_count from accounts.subscriptions as s
                                            where s.subscription_id = new.subscription_id
                                            limit 1);
            if (new.used_resources_count > max_amount) then
                raise integrity_constraint_violation
                    using message = 'Can not use more resources than max amount. Used: ' || new.used_resources_count || '. Max amount: ' || max_amount,
                        constraint = 'used_resources_less_or_equal_max_resources_count';
            end if;
        end if;
        return new;
    end
    $$ language plpgsql;

create trigger check_resources_left_count_for_user
    before insert or update
    on accounts.users_subscriptions
    for each row
    execute function check_resources_left_count_for_user_function();
